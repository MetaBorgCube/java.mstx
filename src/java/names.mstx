import stdlib.paths
import stdlib.sets

import java.types.references



// package-name-ok : scope * PackageName * path

package-name-ok(s, pn, p) :- pn match
  { PackageName(id) ->
      lexical-package-name(s, id, p)
  | PackageName(pn, id) -> {p', s_pkg}
      package-name-ok(s, pn, p')
    , package-scope(p', s_pkg)
    , member-package-name(s_pkg, id, p)
  }.

lexical-package-name(s, id, p) :- {pkgs, idpkgs, idpkgs'}
  query s
        (`LEX|`CU)* `PKG // LEX-PKG-RE
        as pkgs
, filter pkgs ((id', _) where id' == id) idpkgs
, min idpkgs lexico(
        `PKG < `LEX // PKG-ORD
      ) idpkgs'
, only(idpkgs', p).

member-package-name(s, id, p) :- {pkgs, idpkgs, idpkgs}
  query s
        `PKG // MEM-PKG-RE
        as pkgs
, filter pkgs ((id', _) where id' == id) idpkgs
, only(idpkgs, p).



// type-name-ok : scope * TypeName * path

type-name-ok(s, tn, p) :- tn match
  { TypeName(id) ->
      lexical-type-name(s, id, p)
  | TypeName(ptn, id) -> {n, p', s', types, idtypes}
      package-or-type-name-ok(s, ptn, n)
    , n match
        { PKG(p') ->
            package-scope(p', s')
        | TYPE(p') -> {id', ty}
            datum(p', (id', ty))
          , type-scope(ty, s')
        }
    , member-type-name(s', id, p)
  }.

lexical-type-name(s, id, p) :- {types, idtypes, idtypes'}
  query s
        (`LEX|`CU)* `IMP? `EXT* `IMPL* `TYPE // LEX-TYPE-RE
        as types
, filter types ((id', _) where id' == id) idtypes
, min idtypes lexico(
        `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMP, `TYPE < `IMPL, `EXT < `LEX, `IMPL < `LEX, `IMP < `LEX // TYPE-ORD
      ) idtypes'
, only(idtypes', p).

member-type-name(s, id, p) :- {types, idtypes, idtypes'}
  query s
        `EXT* `IMPL* `TYPE // MEM-TYPE-RE
        as types
, filter types ((id', _) where id' == id) idtypes
, min idtypes lexico(
        `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMP, `TYPE < `IMPL, `EXT < `LEX, `IMPL < `LEX, `IMP < `LEX // TYPE-ORD
      ) idtypes'
, only(idtypes, p).



// package-or-type-name-ok : scope * PackageOrTypeName * path

package-or-type-name-ok(s, ptn, n) :- ptn match
  { PackageOrTypeName(id) -> 
    // Type -> TypeName
    // -> PackageName
    lexical-package-or-type-name(s, id, n)
  | PackageOrTypeName(ptn, id) -> {n'}
    // Type =>
    //   -> TypeName
    // Pkg =>
    //   Type -> TypeName
    //   -> PackageName
      package-or-type-name-ok(s, ptn, n')
    , n' match
        { PKG(p') -> {s_pkg}
            package-scope(p', s_pkg)
          , member-package-or-type-name(s_pkg, id, n)
        | TYPE(p') -> {id', ty, s_ty, p}
            datum(p', (id', ty))
          , type-scope(ty, s_ty)
          , member-type-name(s_ty, id, p)
          , n == TYPE(p)
        }
  }.

lexical-package-or-type-name(s, id, n) :- {names, id-names, id-names', id-names'', p, l}
  query s
        (`LEX|`CU)* `PKG | (`LEX|`CU)* `IMP? `EXT* `IMPL* `TYPE // LEX-PKG-OR-TYPE-RE
        as names
, filter names ((id', _) where id' == id) id-names
, min id-names reverse-lexico(
        `TYPE < `PKG
      ) id-names'
, min id-names' lexico(
        `PKG < `LEX, `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMP, `TYPE < `IMPL, `EXT < `LEX, `IMPL < `LEX, `IMP < `LEX // PKG-OR-TYPE-ORD
      ) id-names''
, only(id-names'', p)
, tgt-lbl(p, l)
, l match
    { `TYPE -> n == TYPE(p)
    | `PKG  -> n == PKG(p)
    }.

member-package-or-type-name(s, id, n) :- {names, id-names, id-names', id-names'', p', l}
  query s
        `PKG | `EXT* `IMPL* `TYPE // MEM-PKG-OR-TYPE-RE
        as names
, filter names ((id', _) where id' == id) id-names
, min id-names reverse-lexico(
        `TYPE < `PKG
      ) id-names'
, min id-names' lexico(
        `PKG < `LEX, `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMP, `TYPE < `IMPL, `EXT < `LEX, `IMPL < `LEX, `IMP < `LEX // PKG-OR-TYPE-ORD
      ) id-names''
, only(id-names'', p')
, tgt-lbl(p', l)
, l match
    { `TYPE -> n == TYPE(p')
    | `PKG  -> n == PKG(p')
    }.



// expression-name-ok : scope * ExpressionName * path

expression-name-ok(s, en, p) :- en match
  { ExpressionName(id) ->
      lexical-expression-name(s, id, p)
  | ExpressionName(an, id) -> {n}
      ambiguous-name-ok(s, an, n)
    , n match
        { EXPR(p') -> {id', ty, s_ty}
            datum(p', (id', ty))
          , instance-scope(ty, s_ty)
          , member-expression-name(s_ty, id, p)
        }
  }.

lexical-expression-name(s, id, p) :- {names, id-names, id-names'}
  query s
        `LEX* `EXT* (`VAR|`FIELD) // LEX-EXPR-RE
        as names
, filter names ((id', _) where id' == id) id-names
, min id-names lexico(
        `VAR < `LEX, `FIELD < `LEX, `VAR < `EXT, `FIELD < `EXT, `EXT < `LEX // EXPR-ORD
      ) id-names'
, only(id-names', p).

member-expression-name(s, id, p) :- {names, id-names, id-names'}
  query s
        `EXT* (`VAR|`FIELD) // MEM-EXPR-RE
        as names
, filter names ((id', _) where id' == id) id-names
, min id-names lexico(
        `VAR < `LEX, `FIELD < `LEX, `VAR < `EXT, `FIELD < `EXT, `EXT < `LEX // EXPR-ORD
      ) id-names'
, only(id-names', p).



// ambiguous-name-ok : scope * AmbiguousName * path

ambiguous-name-ok(s, an, n) :- an match
  { AmbiguousName(id) -> {names, id-names, id-names', id-names'', p, l}
    // local Var -> ExpressionName
    // static import Var -> ExpressionName
    // local Type -> TypeName
    // (static) import Type -> TypeName
    // -> PackageName
      query s
            (`LEX|`CU)* `PKG | (`LEX|`CU)* `IMP? `EXT* `IMPL* `TYPE | `LEX* `EXT* (`VAR|`FIELD) // AMB-RE
            as names
    , filter names ((id', _) where id' == id) id-names
    , min id-names reverse-lexico(
            `VAR < `TYPE, `VAR < `PKG, `FIELD < `TYPE, `FIELD < `PKG, `TYPE < `PKG
          ) id-names'
    , min id-names' lexico(
            `VAR < `LEX, `FIELD < `LEX, `VAR < `EXT, `FIELD < `EXT, `EXT < `LEX, `PKG < `LEX, `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMP, `TYPE < `IMPL, `EXT < `LEX, `IMPL < `LEX, `IMP < `LEX // AMB-ORD
          ) id-names''
    , only(id-names'', p)
    , tgt-lbl(p, l)
    , l match
        { `VAR   -> n == EXPR(p)
        | `FIELD -> n == EXPR(p)
        | `TYPE  -> n == TYPE(p)
        | `PKG   -> n == PKG(p)
        }
  | AmbiguousName(an, id) -> {n'}
    // Pkg =>
    //   local Type -> TypeName
    //   -> PackageName
    // Type =>
    //   Var (+ Method?) -> ExpressionName
    //   Type -> TypeName
    // Var =>
    //   -> ExpressionName
      ambiguous-name-ok(s, an, n')
    , n' match
        { EXPR(p') -> {id', ty, s_ty, p}
            datum(p', (id', ty))
          , instance-scope(ty, s_ty)
          , member-expression-name(s_ty, id, p)
          , n == EXPR(p)
        }
  }.



// method-name-ok : scope * MethodName * path

method-name-ok(s, mn, p) :- mn match
  { MethodName(id) ->
      false
  }.



package-scope(p, s_pkg) :- {id}
  datum(p, (id, PKG(s_pkg))).
