import stdlib.paths
import stdlib.sets

import java.types.references



// package-name-ok : scope * PackageName * (string * Type)

package-name-ok(s, pn, decl) :- pn match
  { PackageName(id) ->
      lexical-package-name(s, id, decl)
  | PackageName(pn, id) -> {decl', s_pkg}
      package-name-ok(s, pn, decl')
    , package-decl-scope(decl', s_pkg)
    , member-package-name(s_pkg, id, decl)
  }.

lexical-package-name(s, id, decl) :- {pkgs, idpkgs, idpkgs', s_pkg}
  query s
        (`LEX|`CU)* `PKG // LEX-PKG-RE
        as pkgs
, filter pkgs ((id', _) where id' == id) idpkgs
, min idpkgs lexico(
        `PKG < `LEX // PKG-ORD
      ) idpkgs'
, new s_pkg -> decl
, decl == (id, PKG(s_pkg))
, every idpkgs' (s_pkg' -> s_pkg -[ `IMP ]-> s_pkg').

member-package-name(s, id, decl) :- {pkgs, idpkgs, p}
  query s
        `IMP? `PKG // MEM-PKG-RE
        as pkgs
, filter pkgs ((id', _) where id' == id) idpkgs
, only(idpkgs, p)
 // ????
, datum(p, decl).



// type-name-ok : scope * TypeName * (string * Type)

type-name-ok(s, tn, decl) :- tn match
  { TypeName(id) ->
      lexical-type-name(s, id, decl)
  | TypeName(ptn, id) -> {decl', s', types, idtypes}
      package-or-type-name-ok(s, ptn, decl')
    , decl' match
        { PKG(decl')  -> package-decl-scope(decl', s')
        | TYPE(decl') -> type-decl-scope(decl', s')
        }
    , member-type-name(s', id, decl)
  }.

lexical-type-name(s, id, decl) :- {types, idtypes, idtypes', p}
  query s
        (`LEX|`CU)* `IMP? `EXT* `IMPL* `TYPE // LEX-TYPE-RE
        as types
, filter types ((id', _) where id' == id) idtypes
, min idtypes lexico(
        `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMP, `TYPE < `IMPL, `EXT < `LEX, `IMPL < `LEX, `IMP < `LEX // TYPE-ORD
      ) idtypes'
, only(idtypes', p)
, datum(p, decl).

member-type-name(s, id, decl) :- {types, idtypes, idtypes', p}
  query s
        `EXT* `IMPL* `TYPE // MEM-TYPE-RE
        as types
, filter types ((id', _) where id' == id) idtypes
, min idtypes lexico(
        `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMP, `TYPE < `IMPL, `EXT < `LEX, `IMPL < `LEX, `IMP < `LEX // TYPE-ORD
      ) idtypes'
, only(idtypes, p)
, datum(p, decl).



// package-or-type-name-ok : scope * PackageOrTypeName * Name

package-or-type-name-ok(s, ptn, name) :- ptn match
  { PackageOrTypeName(id) -> 
    // Type -> TypeName
    // -> PackageName
    lexical-package-or-type-name(s, id, name)
  | PackageOrTypeName(ptn, id) -> {name'}
    // Type =>
    //   -> TypeName
    // Pkg =>
    //   Type -> TypeName
    //   -> PackageName
      package-or-type-name-ok(s, ptn, name')
    , name' match
        { PKG(decl') -> {s_pkg}
            package-decl-scope(decl', s_pkg)
          , member-package-or-type-name(s_pkg, id, name)
        | TYPE(decl') -> {s_ty, decl''}
            type-decl-scope(decl', s_ty)
          , member-type-name(s_ty, id, decl'')
          , name == TYPE(decl'')
        }
  }.

lexical-package-or-type-name(s, id, name) :- {names, id-names, id-names', id-names'', p, l, decl'}
  query s
        (`LEX|`CU)* `PKG | (`LEX|`CU)* `IMP? `EXT* `IMPL* `TYPE // LEX-PKG-OR-TYPE-RE
        as names
, filter names ((id', _) where id' == id) id-names
, min id-names reverse-lexico(
        `TYPE < `PKG
      ) id-names'
, min id-names' lexico(
        `PKG < `LEX, `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMP, `TYPE < `IMPL, `EXT < `LEX, `IMPL < `LEX, `IMP < `LEX // PKG-OR-TYPE-ORD
      ) id-names''
// kaput
, only(id-names'', p)
, tgt-lbl(p, l)
, datum(p, decl')
, l match
    { `TYPE -> name == TYPE(decl')
    | `PKG  -> name == PKG(decl')
    }.

member-package-or-type-name(s, id, name) :- {names, id-names, id-names', id-names'', p', l, decl''}
  query s
        `IMP? `PKG | `EXT* `IMPL* `TYPE // MEM-PKG-OR-TYPE-RE
        as names
, filter names ((id', _) where id' == id) id-names
, min id-names reverse-lexico(
        `TYPE < `PKG
      ) id-names'
, min id-names' lexico(
        `PKG < `LEX, `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMP, `TYPE < `IMPL, `EXT < `LEX, `IMPL < `LEX, `IMP < `LEX // PKG-OR-TYPE-ORD
      ) id-names''
// kaput
, only(id-names'', p')
, tgt-lbl(p', l)
, datum(p', decl'')
, l match
    { `TYPE -> name == TYPE(decl'')
    | `PKG  -> name == PKG(decl'')
    }.



// expression-name-ok : scope * ExpressionName * (string * Type)

expression-name-ok(s, en, decl) :- en match
  { ExpressionName(id) ->
      lexical-expression-name(s, id, decl)
  | ExpressionName(an, id) -> {name'}
      ambiguous-name-ok(s, an, name')
    , name' match
        { EXPR(decl') -> {s_ty}
            expr-decl-scope(decl', s_ty)
          , member-expression-name(s_ty, id, decl)
        }
  }.

lexical-expression-name(s, id, decl) :- {names, id-names, id-names', p}
  query s
        `LEX* `EXT* (`VAR|`FIELD) // LEX-EXPR-RE
        as names
, filter names ((id', _) where id' == id) id-names
, min id-names lexico(
        `VAR < `LEX, `FIELD < `LEX, `VAR < `EXT, `FIELD < `EXT, `EXT < `LEX // EXPR-ORD
      ) id-names'
, only(id-names', p)
, datum(p, decl).

member-expression-name(s, id, decl) :- {names, id-names, id-names', p}
  query s
        `EXT* (`VAR|`FIELD) // MEM-EXPR-RE
        as names
, filter names ((id', _) where id' == id) id-names
, min id-names lexico(
        `VAR < `LEX, `FIELD < `LEX, `VAR < `EXT, `FIELD < `EXT, `EXT < `LEX // EXPR-ORD
      ) id-names'
, only(id-names', p)
, datum(p, decl).



// ambiguous-name-ok : scope * AmbiguousName * Name

ambiguous-name-ok(s, an, name) :- an match
  { AmbiguousName(id) -> {names, id-names, id-names', id-names'', p, decl', l}
    // local Var -> ExpressionName
    // static import Var -> ExpressionName
    // local Type -> TypeName
    // (static) import Type -> TypeName
    // -> PackageName
      query s
            (`LEX|`CU)* `PKG | (`LEX|`CU)* `IMP? `EXT* `IMPL* `TYPE | `LEX* `EXT* (`VAR|`FIELD) // AMB-RE
            as names
    , filter names ((id', _) where id' == id) id-names
    , min id-names reverse-lexico(
            `VAR < `TYPE, `VAR < `PKG, `FIELD < `TYPE, `FIELD < `PKG, `TYPE < `PKG
          ) id-names'
    , min id-names' lexico(
            `VAR < `LEX, `FIELD < `LEX, `VAR < `EXT, `FIELD < `EXT, `EXT < `LEX, `PKG < `LEX, `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMP, `TYPE < `IMPL, `EXT < `LEX, `IMPL < `LEX, `IMP < `LEX // AMB-ORD
          ) id-names''
    // kaput
    , only(id-names'', p)
    , datum(p, decl')
    , tgt-lbl(p, l)
    , l match
        { `VAR   -> name == EXPR(decl')
        | `FIELD -> name == EXPR(decl')
        | `TYPE  -> name == TYPE(decl')
        | `PKG   -> name == PKG(decl')
        }
  | AmbiguousName(an, id) -> {name'}
    // Pkg =>
    //   local Type -> TypeName
    //   -> PackageName
    // Type =>
    //   Var (+ Method?) -> ExpressionName
    //   Type -> TypeName
    // Var =>
    //   -> ExpressionName
      ambiguous-name-ok(s, an, name')
    , name' match
        { EXPR(decl') -> {s_ty, decl''}
            expr-decl-scope(decl', s_ty)
          , member-expression-name(s_ty, id, decl'')
          , name == EXPR(decl'')
        }
  }.



// method-name-ok : scope * MethodName * path

method-name-ok(s, mn, p) :- mn match
  { MethodName(id) ->
      false
  }.


// helper functions from declarations to scopes

expr-decl-scope(decl, s_ty) :- decl match
  { (_, ty) -> instance-scope(ty, s_ty)
  }.

type-decl-scope(decl, s_ty) :- decl match
  { (_, CLASS(s)) -> s_ty == s
  | (_, INTF(s))  -> s_ty == s
  }.

package-decl-scope(decl, s_pkg) :- decl match
  { (_, PKG(s)) -> s_pkg == s
  }.
