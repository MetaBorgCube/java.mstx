import stdlib.paths

import java.names



// unann-type-ok : scope * UnannType

unann-type-ok(s, ut, ty) :- ut match
  { UPT2UT(upt) -> unann-primitive-type-ok(s, upt, ty)
  | URT2UT(urt) -> unann-reference-type-ok(s, urt, ty)
  }.



// primitive-type-ok : scope * PrimitiveType

primitive-type-ok(s, pt, ty) :- pt match
  { NumericType(annotations, nt) -> numeric-type-ok(s, nt, ty)
  | BooleanType(annotations)     -> ty == BOOLEAN()
  }.

// unann-primitive-type-ok : scope * UnannPrimitiveType

unann-primitive-type-ok(s, upt, ty) :- upt match
  { NumericType(nt) -> numeric-type-ok(s, nt, ty)
  | BooleanType()   -> ty == BOOLEAN()
  }.



// reference-type-ok : scope * ReferenceType * Type

reference-type-ok(s, rt, ty) :- rt match
  { CT2RT(ct) -> class-type-ok(s, ct, ty)
  | AT2RT(uat) -> array-type-ok(s, uat, ty)
  }.

// unann-reference-type-ok : scope * UnannReferenceType * Type

unann-reference-type-ok(s, urt, ty) :- urt match
  { UCT2URT(uct) -> unann-class-type-ok(s, uct, ty)
  | UAT2URT(uat) -> unann-array-type-ok(s, uat, ty)
  }.



// array-type-ok : scope * ArrayType * Type

array-type-ok(s, at, ty) :- at match
  { ArrayTypePrimitive(pt, annotatedDims) -> {ty'}
      primitive-type-ok(s, pt, ty')
    , annotated-dims-ok(annotatedDims, ty', ty)
  | ArrayTypeClassType(ct, annotatedDims) -> {ty'}
      class-type-ok(s, ct, ty')
    , annotated-dims-ok(annotatedDims, ty', ty)
  }.

// unann-array-type-ok : scope * UnannArrayType * Type

unann-array-type-ok(s, at, ty) :- at match
  { ArrayTypePrimitive(upt, annotatedDims) -> {ty'}
      unann-primitive-type-ok(s, upt, ty')
    , annotated-dims-ok(annotatedDims, ty', ty)
  | ArrayTypeClassType(uct, annotatedDims) -> {ty'}
      unann-class-type-ok(s, uct, ty')
    , annotated-dims-ok(annotatedDims, ty', ty)
  }.

annotated-dims-ok(dims, ty', ty) :- dims match
  { []     -> ty == ty'
  | _:dims -> annotated-dims-ok(dims, ARRAY(ty'), ty)
  }.


// numeric-type-ok : scope * NumericType

numeric-type-ok(s, nt, ty) :- nt match
  { Byte()   -> ty == BYTE()
  | Short()  -> ty == SHORT()
  | Int()    -> ty == INT()
  | Long()   -> ty == LONG()
  | Char()   -> ty == CHAR()
  | Float()  -> ty == FLOAT()
  | Double() -> ty == DOUBLE()
  }.



// class-types-ok maps class-type-ok(*, list(*)) == list(*)

class-types-ok(s, cts, tys) :- cts match
  { ct:cts' -> {ty, tys'}
      class-type-ok(s, ct, ty)
    , class-types-ok(s, cts', tys')
    , tys == ty:tys'
  | [] -> tys == []
  }.

// class-type-ok : scope * ClassType -> TYPE

class-type-ok(s, ct, ty) :- {p, id', cls, mtas, tas} ct match
  { ClassType(annotations, id, maybeTypeArguments) ->
      lexical-type-name(s, id, p)
    , mtas == maybeTypeArguments
  | ClassOrInterfaceTypeMember(classType, annotations, id, maybeTypeArguments) -> {s'}
      class-type-or-pkg-ok(s, classType, s')
    , member-type-name(s', id, p)
    , mtas == maybeTypeArguments
  }
, datum(p, (id', cls))
, maybe-type-arguments-ok(s, mtas, tas)
, ty == OBJECT(cls, tas).

class-type-or-pkg-ok(s, ct, s') :- {n, mtas} ct match
  { ClassType(annotations, id, maybeTypeArguments) ->
      lexical-package-or-type-name(s, id, n)
    , mtas == maybeTypeArguments
  | ClassOrInterfaceTypeMember(classType, annotations, id, maybeTypeArguments) -> {s'}
      class-type-or-pkg-ok(s, classType, s')
    , member-package-or-type-name(s', id, n)
    , mtas == maybeTypeArguments
  }
, n match
    { PKG(p') ->
        package-scope(p', s')
      , mtas == None()
    | TYPE(p') -> {id', cls, tas}
        datum(p', (id', cls))
      , type-scope(cls, s')
      , maybe-type-arguments-ok(s, mtas, tas)
    }.



// unann-class-type-ok : scope * UnannClassType

unann-class-type-ok(s, uct, ty) :- {p, id', cls, mtas, tas} uct match
  { ClassType(id, maybeTypeArguments) ->
      lexical-type-name(s, id, p)
    , mtas == maybeTypeArguments
  | ClassOrInterfaceTypeMember(unannClassType, annotations, id, maybeTypeArguments) -> {s'}
      unann-class-type-or-pkg-ok(s, unannClassType, s')
    , member-type-name(s', id, p)
    , mtas == maybeTypeArguments
  }
, datum(p, (id', cls))
, maybe-type-arguments-ok(s, mtas, tas)
, ty == OBJECT(cls, tas).

unann-class-type-or-pkg-ok(s, ct, s') :- {n, mtas} ct match
  { ClassType(id, maybeTypeArguments) ->
      lexical-package-or-type-name(s, id, n)
    , mtas == maybeTypeArguments
  | ClassOrInterfaceTypeMember(unannClassType, annotations, id, maybeTypeArguments) -> {s'}
      unann-class-type-or-pkg-ok(s, unannClassType, s')
    , member-package-or-type-name(s', id, n)
    , mtas == maybeTypeArguments
  }
, n match
    { PKG(p') ->
        package-scope(p', s')
      , mtas == None()
    | TYPE(p') -> {id', cls, tas}
        datum(p', (id', cls))
      , type-scope(cls, s')
      , maybe-type-arguments-ok(s, mtas, tas)
    }.


// type-arguments-ok : scope * list(TypeArgument) * Types

maybe-type-arguments-ok(s, maybeTypeArguments, tps) :- maybeTypeArguments match
  { None()                    -> tps == []
  | Some(TypeArguments(ftps)) -> type-arguments-ok(s, ftps, tps)
  }.

type-arguments-ok(s, typeArguments, tps) :- typeArguments match
  { ta:tas -> {tp, tps'}
      tps == tp:tps'
    , type-argument-ok(s, ta, tp)
    , type-arguments-ok(s, tas, tps')
  | [] -> tps == []
  }.

// type-argument-ok : scope * TypeArgument * Type

type-argument-ok(s, ta, tp) :- ta match
  { RT2TA(rt) -> 
      reference-type-ok(s, rt, tp)
  }.

is-class-or-interface-type(tp) :- tp match
  { OBJECT(CLASS(_,_),_)  -> true
  | OBJECT(INTF(_,_),_)   -> true
  | otherwise             -> false
  }.

is-interface-type(tp) :- tp match
  { OBJECT(INTF(_,_),_)   -> true
  | _ -> false }.

are-interface-types(tps) :- tps match
  { tp:tps    -> is-interface-type(tp), are-interface-types(tps)
  | []        -> true
  }.

type-scope(ty, s_ty) :- ty match
  { CLASS(s_cls,_) -> s_ty == s_cls
  | INTF(s_intf,_) -> s_ty == s_intf
  }.

instance-scope(ty, s_ty) :- ty match { OBJECT(tydecl,_) -> type-scope(tydecl, s_ty) }.

type-formal-params(ty, ftps) :- ty match
  { CLASS(_,gens)  -> ftps == gens
  | INTF(_,gens)   -> ftps == gens
  }.

