main(tm) :- tm match
  { CompilationUnit(pkgDecl, imports, typeDecls) -> {s}
      new s
    , type-declarations-ok(s, typeDecls)
  }.

// type-declarations-ok maps type-declaration-ok(*, list(*))

type-declarations-ok(s, tds) :- tds match
  { []     -> true
  | td:tds -> type-declaration-ok(s, td), type-declarations-ok(s, tds)
  }.

// type-declaration-ok : scope * TypeDeclaration

type-declaration-ok(s, td) :- td match
  { TD2CD(cd) -> class-declaration-ok(s, cd)
  | TD2ID(id) -> interface-declaration-ok(s, id)
  | SemiColon() -> true
  }.

// class-declaration-ok : scope * ClassDeclaration

class-declaration-ok(s, cd) :- cd match
  { CD2NCD(ncd) -> normal-class-declaration-ok(s, ncd)
  }.

// normal-class-declaration-ok : scope * NormalClassDeclaration

normal-class-declaration-ok(s, ncd) :- ncd match
  { ClassDeclaration(classModifiers, id, maybeTypeParameters, maybeSuperClass, maybeSuperInterfaces, classBodyDeclarations) -> {s_cls}
      new s_cls -> (id, CLASS(s_cls))
    , s_cls -[ `LEX ]-> s
    , s -[ `TYPE ]-> s_cls
    , maybe-super-class-ok(s, maybeSuperClass, s_cls)
    , maybe-super-interfaces-ok(s, maybeSuperInterfaces, s_cls)
    , class-body-declarations-ok(s_cls, classBodyDeclarations)
  }. 

// interface-declaration-ok : scope * InterfaceDeclaration

interface-declaration-ok(s, id) :- id match
  { NormalInterface(interfaceModifiers, id, maybeTypeParameters, maybeExtendsInterfaces, interfaceMemberDeclarations) -> {s_intf}
      new s_intf -> (id, INTF(s_intf))
    , s_intf -[ `LEX ]-> s
    , s -[ `TYPE ]-> s_intf
    , maybe-extends-interfaces-ok(s, maybeExtendsInterfaces, s_intf)
    , interface-member-declarations-ok(s_intf, interfaceMemberDeclarations)
  }. 

// maybe-superclass-ok maps super-class-ok(*, list(*), *)

maybe-super-class-ok(s, sc, s_this) :- sc match
  { None()   -> true
  | Some(sc) -> super-class-ok(s, sc, s_this)
  }.

// superclass-ok : scope * SuperClass * scope

super-class-ok(s, sc, s_this) :- sc match
  { SuperClass(classType) -> {s_super}
      class-type-ok(s, classType, CLASS(s_super))
    , s_this -[ `EXT ]-> s_super
  }.

// maybe-super-interfaces-ok maps super-interfaces-ok(*, list(*), *)

maybe-super-interfaces-ok(s, si, s_this) :- si match
  { None()   -> true
  | Some(si) -> super-interfaces-ok(s, si, s_this)
  }.

// super-interfaces-ok : scope * SuperInterfaces * scope

super-interfaces-ok(s, si, s_this) :- si match
  { SuperInterface(classTypes) -> {types}
      class-types-ok(s, classTypes, types)
    , implement-interfaces(types, s)
  }.

// implement-interfaces maps implement-interface(list(*), *)

implement-interfaces(is, s_this) :- is match
  { []   -> true
  | i:is -> implement-interface(i, s_this), implement-interfaces(is, s_this)
  }.

// implement-interface : TYPE * scope

implement-interface(i, s_this) :- i match
  { INTF(s_intf) ->
      s_this -[ `IMPL ]-> s_intf
  }.

// class-body-declarations-ok maps class-body-declaration-ok(*, list(*))

class-body-declarations-ok(s, cbds) :- cbds match
  { []       -> true
  | cbd:cbds -> class-body-declaration-ok(s, cbd), class-body-declarations-ok(s, cbds)
  }.

// class-body-declaration-ok : scope * ClassBodyDeclaration

class-body-declaration-ok(s, cbd) :- cbd match
  { CBD2CMD(cmd) -> class-member-declaration-ok(s, cmd)
  }.

// class-member-declaration-ok : scope * ClassMemberDeclaration

class-member-declaration-ok(s, cmd) :- cmd match
  { CMD2FD(fd) -> field-declaration-ok(s, fd)
  | CMD2MD(md) -> method-declaration-ok(s, md)
  | CMD2CD(cd) -> class-declaration-ok(s, cd)
  | CMD2ID(id) -> interface-declaration-ok(s, id)
  | SemiColon() -> true
  }.

// field-declaration-ok : scope * FieldDeclaration

field-declaration-ok(s, fd) :- fd match
  { FieldDecl(fieldModifiers, unannType, varDecls) -> {ty}
      unann-type-ok(s, unannType, ty)
    , var-decls-ok(s, varDecls)
    , true // TODO
  }.

// var-decl-id-ok : scope * VarDeclId

var-decl-id-ok(s, vdi) :- vdi match
  { VariableDecl(id) ->
      true // TODO
  }.

// var-decls-ok : scope * list(VarDecl)

var-decls-ok(s, vds) :- vds match
  { []     -> true
  | vd:vds -> var-decl-ok(s, vd), var-decls-ok(s, vds)
  }.

// var-decl-ok : scope * VarDecl

var-decl-ok(s, vd) :- vd match
  { VariableDeclInit(vdi, vi) ->
      var-decl-id-ok(s, vdi)
    , true // TODO
  | VD2VDI(vdi) ->
      var-decl-id-ok(s, vdi)
  }.

// variable-initializer-ok : scope * VariableInitializer

variable-initializer-ok(s, vi) :- vi match
  { VI2E(e) -> {ty}
      expression-ok(s, e, ty)
  }.

// method-declaration-ok : scope * MethodDeclaration

method-declaration-ok(s, md) :- md match
  { MethodDecl(methodModifiers, methodHeader, methodBody) -> {s_method, decl}
      new s_method -> decl
    , s_method -[ `LEX ]-> s
    , method-header-ok(s, methodHeader, decl)
    , method-body-ok(s_method, methodBody)
  }.

// method-header-ok : scope * MethodHeader * (Id, Type)

method-header-ok(s, mh, decl) :- mh match
  { MethodHeader(result, id, formalParams, annotatedDimsEmpty, maybeThrows) -> {ty, tys}
      decl = (id, METHOD(ty, tys))
    , true // TODO
    , result-ok(s, result, ty)
  }.

// result-ok : scope * Result * tys * ty

result-ok(s, r, ty) :- r match
  { R2UT(ut) -> unann-type-ok(s, ut, ty)
  | Void()   -> ty = VOID()
  }.

// formal-params-ok : scope * FormalParams

formal-params-ok(s, fps, tys) :- fps match
  { NoParams() ->
      tys = []
  | SingleParam(lfp) -> {ty}
      last-formal-param-ok(s, lfp, ty)
    , tys = ty:[]
  | ParamList([], lfp) ->
      formal-params-ok(s, SingleParam(lfp), tys)
  | ParamList(fp:fps, lfp) -> {ty, tys'}
      formal-param-ok(s, fp, ty)
    , formal-params-ok(s, ParamList(fps, lfp), tys')
    , tys = ty:tys'
  }.

last-formal-param-ok(s, lfp, ty) :- lfp match
  { LFP2FP(fp) -> formal-param-ok(s, fp, ty)
  }.

formal-param-ok(s, fp, ty) :- fp match
  { FormalParam(variableModifiers, unannType, varDeclId) ->
      unann-type-ok(s, unannType, ty)
    , true // TODO
  }.

// method-body-ok : scope * MethodBody

method-body-ok(s, mb) :- mb match
  { MB2B(b)        -> block-ok(s, b)
  | NoMethodBody() -> true
  }.

// maybe-extendsinterfaces-ok maps extends-interfaces-ok(*, list(*))

maybe-extends-interfaces-ok(s, ei, s_this) :- ei match
  { None()   -> true
  | Some(ei) -> extends-interfaces-ok(s, ei, s_this)
  }.

// extends-interfaces-ok : scope * ExtendsInterfaces * scope

extends-interfaces-ok(s, ei, s_this) :- ei match
  { ExtendsInterfaces(classTypes) -> {types}
      class-types-ok(s, classTypes, types)
    , implement-interfaces(types, s_this)
  }.

// interface-member-declarations-ok maps interface-member-declaration-ok(*, list(*))

interface-member-declarations-ok(s, imds) :- imds match
  { []       -> true
  | imd:imds -> interface-member-declaration-ok(s, imd), interface-member-declarations-ok(s, imds)
  }.

// interface-member-declaration-ok : scope * InterfaceMemberDeclaration

interface-member-declaration-ok(s, imd) :- imd match
  { IMD2IMD(imd) -> interface-method-declaration-ok(s, imd)
  | IMD2CD(cd) -> class-declaration-ok(s, cd)
  | IMD2ID(id) -> interface-declaration-ok(s, id)
  | SemiColon() -> true
  }.

interface-method-declaration-ok(s, imd) :- imd match
  { AbstractMethodDec(interfaceMethodModifiers, methodHeader, methodBody) -> {s_method}
      new s_method
    , s_method -[ `LEX ]-> s
    , method-body-ok(s_method, methodBody)
    , true // TODO
  }.

// block-ok : scope * Block

block-ok(s, b) :- b match
  { Block(blockStatements) ->
      block-statements-ok(s, blockStatements)
  }.

// block-statements-ok : scope * BlockStatement

block-statements-ok(s, bs) :- bs match
  { [] -> true
  | BS2LVSD(lvsd):bs -> {s_blk}
      new s_blk
    , s_blk -[ `LEX ]-> s
    , true // TODO
    , block-statements-ok(s_blk, bs)
  | BS2CD(cd):bs -> {s_blk}
      new s_blk
    , s_blk -[ `LEX ]-> s
    , class-declaration-ok(s_blk, cd)
    , block-statements-ok(s_blk, bs)
  | BS2S(s):bs ->
      true // TODO
    , block-statements-ok(s, bs)
  }.

// expression-ok : scope * Expression * Type

expression-ok(s, e, ty) :-
  true. // TODO

// class-types-ok maps class-type-ok(*, list(*)) = list(*)

class-types-ok(s, cts, tys) :- {ct-ty-s}
  zip(cts, tys, ct-ty-s)
, ct-ty-s match
  { (ct, ty) -> class-type-ok(s, ct, ty)
  }.

// class-type-ok : scope * ClassType -> TYPE

class-type-ok(s, ct, ty) :- ct match
  { ClassType(annotations, id, maybeTypeArguments) -> {reached}
      query s `LEX*`IMPORT*`TYPE as reached
    , one-class-type(reached, id, ty)
  | ClassOrInterfaceTypeMember(classType, annotations, id, maybeTypeArguments) -> {s_cls, reached}
      class-type-ok(s, classType, CLASS(s_cls))
    , query s `TYPE as reached
    , one-class-type(reached, id, ty)
  }.

one-class-type(reached, id, ty) :- {matched, visible, p}
  filter reached ((id', ty') where id' = id) matched
, min matched lexico(`TYPE < `LEX) visible
, only(visible, p)
, datum(p, (id, ty)).

// unann-type-ok : scope * UnannType

unann-type-ok(s, ut, ty) :- ut match
  { UT2UPT(upt) -> unann-primitive-type-ok(s, upt, ty)
  | UT2URT(urt) -> unann-reference-type-ok(s, urt, ty)
  }.

// unann-primitive-type-ok : scope * UnannPrimitiveType

unann-primitive-type-ok(s, upt, ty) :- upt match
  { NumericType(nt) -> numeric-type-ok(s, nt, ty)
  | BooleanType()   -> ty = BOOLEAN()
  }.

// unann-reference-type-ok : scope * UnannReferenceType

unann-reference-type-ok(s, urt, ty) :- urt match
  { URT2UCT(uct) -> unann-class-type-ok(s, uct, ty)
  }.

// unann-class-type-ok : scope * UnannClassType

unann-class-type-ok(s, urt, ty) :- urt match
  { ClassType(id, maybeTypeArguments) ->
      true // TODO
  | ClassOrInterfaceType(unannClassType, annotations, id, maybeTypeArguments) ->
      true // TODO
  }.

// numeric-type-ok : scope * NumericType

numeric-type-ok(s, nt, ty) :- nt match
  { Byte()   -> ty = BYTE()
  | Short()  -> ty = SHORT()
  | Int()    -> ty = INT()
  | Long()   -> ty = LONG()
  | Char()   -> ty = CHAR()
  | Float()  -> ty = FLOAT()
  | Double() -> ty = DOUBLE()
  }.

// zip : list(X) * list(Y) -> list(X * Y)

zip(xs,ys,xys) :- (xs, ys) match
  { ([], [])     -> xys = []
  | (x:xs, y:ys) -> {xys2} xys = (x,y):xys2, zip(xs, ys, xys2)
  }.

// ----------------

// s is the target scope of a path p
tgt(p,s) :- p match
  { end(x)       -> s = x
  | edge(x,l,xs) -> tgt(xs,s)
  }.

// s is the source scope of a path p
src(p,s) :- p match
  { end(x)       -> s = x
  | edge(x,l,xs) -> s = x
  }.

// d is the datum of the target of p
datum(p,d) :- {s} tgt(p, s), s -> d.
