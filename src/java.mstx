//
// Type Declarations are:
//   CLASS(<class-scope>, [<generics>])
//   INTF(<intf-scope>, [<generics>])
//   TVAR(<tvar-declaration-node>, [<upper-bounds>])

// Types are
//   OBJECT(<class or interface declaration>, [<type arguments>])
//   TVAR(<tvar-declaration-node>)

main(tm) :- tm match
  { CompilationUnit(pkgDecl, imports, typeDecls) -> {s}
      new s
    , type-declarations-ok(s, typeDecls)
  }.

// type-declarations-ok maps type-declaration-ok(*, list(*))

type-declarations-ok(s, tds) :- tds match
  { []     -> true
  | td:tds -> type-declaration-ok(s, td), type-declarations-ok(s, tds)
  }.

// type-declaration-ok : scope * TypeDeclaration

type-declaration-ok(s, td) :- td match
  { TD2CD(cd) -> class-declaration-ok(s, cd)
  | TD2ID(id) -> interface-declaration-ok(s, id)
  | SemiColon() -> true
  }.

// class-declaration-ok : scope * ClassDeclaration

class-declaration-ok(s, cd) :- cd match
  { CD2NCD(ncd) -> normal-class-declaration-ok(s, ncd)
  }.

// normal-class-declaration-ok : scope * NormalClassDeclaration

normal-class-declaration-ok(s_pkg, ncd) :- ncd match
  { ClassDeclaration(classModifiers, id, maybeTypeParameters, maybeSuperClass, maybeSuperInterfaces, classBodyDeclarations) -> 
    {s_cls, s_header, tps, s_this, self}
      new s_header
    , new s_cls -> (id, self)

    // generics
    , maybe-type-parameter-decls-ok(s_header, maybeTypeParameters, tps)

    // check the header
    , maybe-super-class-ok(s_header, maybeSuperClass, s_cls)
    , maybe-super-interfaces-ok(s_header, maybeSuperInterfaces, s_cls)

    , self = CLASS(s_cls, tps)
    , s_cls    -[ `LEX  ]-> s_header
    , s_header -[ `LEX  ]-> s_pkg
    , s_pkg    -[ `TYPE ]-> s_cls

    // this
    , new s_this -> OBJECT(self, tps)
    , s_cls -[ `THIS ]-> s_this

    // body
    , class-body-declarations-ok(s_cls, classBodyDeclarations)
  }. 

maybe-type-parameter-decls-ok(s_cls, maybeTypeParameters, tps) :- maybeTypeParameters match
  { None()                    -> tps = []
  | Some(TypeParameters(ftps)) -> type-parameter-decls-ok(s_cls, ftps, tps)
  }.

// type parameter list
// - scoping rules in sectio 6.3 and 6.4
// - syntax in section 8.1.2
// - extends section looks like (extends ClassOrInterfaceType|TypeVar [& InterfaceType]*)
type-parameter-decls-ok(s_cls, typeParameters, tps) :- typeParameters match
  { ftp:ftps -> {tp, tps'}
      tps = tp:tps'
    , type-parameter-decl-ok(s_cls, ftp, tp)
    , type-parameter-decls-ok(s_cls, ftps, tps')
  | [] -> tps = []
  }.

type-parameter-decl-ok(s_cls, typeParameter, tp) :- typeParameter match
  { TypeParameter(annots, name) -> decl-type-param(s_cls, name, [], tp)
  | TypeParameterExtendsClassType(annots, name, fcts) -> {cts}
      class-types-ok(s_cls, fcts, cts)
    , type-bounds-ok(cts)
    , decl-type-param(s_cls, name, cts, tp)
  }.

type-bounds-ok(cts) :- cts match
  { fst:cts' -> are-interfaces(cts') // first bound can be a class identifier
  | []       -> true
  }.

decl-type-param(s, name, bounds, n_param) :- {n_bounds}
      new n_param -> (name, TVAR(n_param))
    , s -[ `TYPE ]-> n_param
    , new n_bounds -> bounds
    , n_param -[ `BOUNDS ]-> n_bounds.

// interface-declaration-ok : scope * InterfaceDeclaration

interface-declaration-ok(s_pkg, id) :- id match
  { NormalInterface(interfaceModifiers, id, maybeTypeParameters, maybeExtendsInterfaces, interfaceMemberDeclarations) -> 
    {s_header, s_intf, s_this, self, tps}
      new s_header
    , new s_intf -> (id, self)

    // generics
    , maybe-type-parameter-decls-ok(s_header, maybeTypeParameters, tps)

    // header
    , maybe-extends-interfaces-ok(s_header, maybeExtendsInterfaces, s_intf)

    , self = INTF(s_intf, tps)
    , s_intf   -[ `LEX  ]-> s_header
    , s_header -[ `LEX  ]-> s_pkg
    , s_pkg    -[ `TYPE ]-> s_intf

    // this
    , new s_this -> OBJECT(self, tps)
    , s_intf -[ `THIS ]-> s_this
    
    // body
    , interface-member-declarations-ok(s_intf, interfaceMemberDeclarations)
  }. 

// maybe-super-class-ok maps super-class-ok(*, list(*), *)

maybe-super-class-ok(s, sc, s_this) :- sc match
  { None()   -> true
  | Some(sc) -> super-class-ok(s, sc, s_this)
  }.

// superclass-ok : scope * SuperClass * scope

super-class-ok(s, sc, s_this) :- sc match
  { SuperClass(classType) -> {s_super, targs, formals}
      class-type-ok(s, classType, OBJECT(CLASS(s_super, formals), targs))
    , s_this -[ `EXT(targs) ]-> s_super
    // TODO see if targs matches gens
  }.

// maybe-super-interfaces-ok maps super-interfaces-ok(*, list(*), *)

maybe-super-interfaces-ok(s, si, s_this) :- si match
  { None()   -> true
  | Some(si) -> super-interfaces-ok(s, si, s_this)
  }.

// super-interfaces-ok : scope * SuperInterfaces * scope

super-interfaces-ok(s, si, s_this) :- si match
  { SuperInterface(classTypes) -> {types}
      class-types-ok(s, classTypes, types)
    , implement-interfaces(types, s_this)
  }.

// implement-interfaces maps implement-interface(list(*), *)

implement-interfaces(is, s_this) :- is match
  { []   -> true
  | i:is -> implement-interface(i, s_this), implement-interfaces(is, s_this)
  }.

// implement-interface : TYPE * scope

implement-interface(i, s_this) :- i match
  { OBJECT(INTF(s_intf, _), targs) -> s_this -[ `IMPL(targs) ]-> s_intf }.

// class-body-declarations-ok maps class-body-declaration-ok(*, list(*))

class-body-declarations-ok(s, cbds) :- cbds match
  { []       -> true
  | cbd:cbds -> class-body-declaration-ok(s, cbd), class-body-declarations-ok(s, cbds)
  }.

// class-body-declaration-ok : scope * ClassBodyDeclaration

class-body-declaration-ok(s, cbd) :- cbd match
  { CBD2CMD(cmd) -> class-member-declaration-ok(s, cmd)
  }.

// class-member-declaration-ok : scope * ClassMemberDeclaration

class-member-declaration-ok(s, cmd) :- cmd match
  { CMD2FD(fd) -> field-declaration-ok(s, fd)
  | CMD2MD(md) -> method-declaration-ok(s, md)
  | CMD2CD(cd) -> class-declaration-ok(s, cd)
  | CMD2ID(id) -> interface-declaration-ok(s, id)
  | SemiColon() -> true
  }.

// field-declaration-ok : scope * FieldDeclaration

field-declaration-ok(s, fd) :- fd match
  { FieldDecl(fieldModifiers, unannType, varDecls) -> {ty}
      unann-type-ok(s, unannType, ty)
    , var-decls-ok(s, varDecls, s, ty)
  }.

// var-decls-ok : scope * list(VarDecl) * Type

var-decls-ok(s, vds, s_def, ty) :- vds match
  { []     -> true
  | vd:vds -> var-decl-ok(s, vd, s_def, ty), var-decls-ok(s, vds, s_def, ty)
  }.

// var-decl-ok : scope * VarDecl * Type

var-decl-ok(s, vd, s_def, ty) :- vd match
  { VariableDeclInit(vdi, vi) ->
      var-decl-id-ok(vdi, s_def, ty)
    , variable-initializer-ok(s, vi, ty)
  | VD2VDI(vdi) ->
      var-decl-id-ok(vdi, s_def, ty)
  }.

// var-decl-id-ok : VarDeclId * scope * Type

var-decl-id-ok(vdi, s_def, ty) :- vdi match
  { VariableDecl(id) -> {s_var}
      new s_var -> (id, ty)
    , s_def -[ `VAR ]-> s_var
  }.

// variable-initializer-ok : scope * VariableInitializer * Type

variable-initializer-ok(s, vi, ty) :- vi match
  { VI2E(e) -> {ty_e}
      expression-ok(s, e, ty_e)
    , sub-type(ty_e, ty)
  }.

// method-declaration-ok : scope * MethodDeclaration

method-declaration-ok(s, md) :- md match
  { MethodDecl(methodModifiers, methodHeader, methodBody) -> {s_method, decl}
      new s_method -> decl
    , s_method -[ `LEX ]-> s
    , s -[ `METHOD ]-> s_method
    , method-header-ok(s_method, methodHeader, decl)
    , method-body-ok(s_method, methodBody)
  }.

// method-header-ok : scope * MethodHeader * (Id, Type)

method-header-ok(s, mh, decl) :- mh match
  { MethodHeader(result, id, formalParams, annotatedDimsEmpty, maybeThrows) -> {ty, tys, s_ret}
      decl = (id, METHOD(ty, tys))
    , formal-params-ok(s, formalParams, tys)
    , result-ok(s, result, ty)
    , new s_ret -> ty
    , s -[ `RETURN ]-> s_ret
  }.

// result-ok : scope * Result * tys * ty

result-ok(s, r, ty) :- r match
  { R2UT(ut) -> unann-type-ok(s, ut, ty)
  | Void()   -> ty = VOID()
  }.

// formal-params-ok : scope * FormalParams

formal-params-ok(s, fps, tys) :- fps match
  { NoParams() ->
      tys = []
  | SingleParam(lfp) -> {ty}
      last-formal-param-ok(s, lfp, ty)
    , tys = ty:[]
  | ParamList([], lfp) ->
      formal-params-ok(s, SingleParam(lfp), tys)
  | ParamList(fp:fps, lfp) -> {ty, tys'}
      formal-param-ok(s, fp, ty)
    , formal-params-ok(s, ParamList(fps, lfp), tys')
    , tys = ty:tys'
  }.

last-formal-param-ok(s, lfp, ty) :- lfp match
  { LFP2FP(fp) -> formal-param-ok(s, fp, ty)
  }.

formal-param-ok(s, fp, ty) :- fp match
  { FormalParam(variableModifiers, unannType, varDeclId) ->
      unann-type-ok(s, unannType, ty)
    , var-decl-id-ok(varDeclId, s, ty)
  }.

// method-body-ok : scope * MethodBody

method-body-ok(s, mb) :- mb match
  { MB2B(b)        -> block-ok(s, b)
  | NoMethodBody() -> true
  }.

// maybe-extendsinterfaces-ok maps extends-interfaces-ok(*, list(*))

maybe-extends-interfaces-ok(s, ei, s_this) :- ei match
  { None()   -> true
  | Some(ei) -> extends-interfaces-ok(s, ei, s_this)
  }.

// extends-interfaces-ok : scope * ExtendsInterfaces * scope

extends-interfaces-ok(s, ei, s_this) :- ei match
  { ExtendsInterfaces(classTypes) -> {types}
      class-types-ok(s, classTypes, types)
    , implement-interfaces(types, s_this)
  }.

// interface-member-declarations-ok maps interface-member-declaration-ok(*, list(*))

interface-member-declarations-ok(s, imds) :- imds match
  { []       -> true
  | imd:imds -> interface-member-declaration-ok(s, imd), interface-member-declarations-ok(s, imds)
  }.

// interface-member-declaration-ok : scope * InterfaceMemberDeclaration

interface-member-declaration-ok(s, imd) :- imd match
  { IMD2IMD(imd) -> interface-method-declaration-ok(s, imd)
  | IMD2CD(cd) -> class-declaration-ok(s, cd)
  | IMD2ID(id) -> interface-declaration-ok(s, id)
  | SemiColon() -> true
  }.

interface-method-declaration-ok(s, imd) :- imd match
  { AbstractMethodDec(interfaceMethodModifiers, methodHeader, methodBody) -> {s_method, decl}
      new s_method -> decl
    , s_method -[ `LEX ]-> s
    , s -[ `METHOD ]-> s_method
    , method-header-ok(s_method, methodHeader, decl)
    , method-body-ok(s_method, methodBody)
  }.

// block-ok : scope * Block

block-ok(s, b) :- b match
  { Block(blockStatements) ->
      block-statements-ok(s, blockStatements)
  }.

// block-statements-ok : scope * BlockStatement

block-statements-ok(s, bs) :- bs match
  { [] -> true
  | BS2LVDS(lvds):bs -> {s_blk}
      new s_blk
    , s_blk -[ `LEX ]-> s
    , local-variable-declaration-statement-ok(s_blk, lvds)
    , block-statements-ok(s_blk, bs)
  | BS2CD(cd):bs -> {s_blk}
      new s_blk
    , s_blk -[ `LEX ]-> s
    , class-declaration-ok(s_blk, cd)
    , block-statements-ok(s_blk, bs)
  | BS2S(stmt):bs ->
      statement-ok(s, stmt)
    , block-statements-ok(s, bs)
  }.

// local-variable-declaration-statement-ok : 

local-variable-declaration-statement-ok(s, lvds) :- lvds match
  { LocVarDeclStm(lvd) -> local-variable-declaration-ok(s, lvd)
  }.

local-variable-declaration-ok(s, lvd) :- lvd match
  { LocalVarDecl(variableModifiers, unannType, varDecls) -> {ty}
      unann-type-ok(s, unannType, ty)
    , var-decls-ok(s, varDecls, s, ty)
  }.

// statement-ok : scope * Statements

statement-ok(s, stmt) :- stmt match
  { S2B(b) ->
      block-ok(s, b)
  | Empty() ->
      true
  | ExpressionStatement(e) -> {ty}
      expression-ok(s, e, ty)
  | Return() -> {ty_ret}
      return-type(s, VOID())
  | Return(e) -> {ty_e, ty_ret}
      expression-ok(s, e, ty_e)
    , return-type(s, ty_ret)
    , sub-type(ty_e, ty_ret)
  }.

// expressions-ok : scope * list(Expression) * list(Type)

expressions-ok(s, es, tys) :- es match
  { []   -> tys = []
  | e:es -> {ty, tys'}
      expression-ok(s, e, ty)
    , expressions-ok(s, es, tys')
    , tys = ty:tys'
  }.

// expression-ok : scope * Expression * Type

expression-ok(s, e, ty) :- e match
  { This() ->
      this-type(s, ty)
  | QThis(typeName) -> {x, p, ty_this}
      type-name-ok(s, typeName, p)
    , datum(p, (x, ty))
    , this-type(s, ty_this)
    , sub-type(ty_this, ty)
  | CastPrimitive(primitiveType, e) -> {ty_e}
      primitive-type-ok(s, primitiveType, ty)
    , expression-ok(s, e, ty_e)
    , sub-type(ty_e, ty)
  | CastReference(referenceType, additionalBounds, e) -> {ty_e}
      reference-type-ok(s, referenceType, ty)
    , additionalBounds match
        { []  -> true
        | _:_ -> false // TODO create anonymous type
        }
    , expression-ok(s, e, ty_e)
    , sub-type(ty_e, ty)
  | Assign(lhs, e) -> {ty_e}
      lhs-ok(s, lhs, ty)
    , expression-ok(s, e, ty_e)
    , sub-type(ty_e, ty)
  | E2FA(fieldAccess) ->
      field-access-ty(s, fieldAccess, ty)
  | E2UI(unqualifiedInstance) ->
      unqualified-instance-ok(s, unqualifiedInstance, ty)
  | QualifiedInstance(e, unqualifiedInstance) -> {ty_e, s_ty}
      expression-ok(s, e, ty_e)
    , type-scope(ty_e, s_ty)
    , qualified-instance-ok(s, unqualifiedInstance, s_ty, ty)
  | E2L(literal) ->
      literal-type(s, literal, ty)
  | E2EN(en) -> {x, p}
      expression-name-ok(s, en, p)
    , normalized-field-ty(p, [], ty)
  }.

lhs-ok(s, lhs, ty) :- lhs match
  { LHS2EN(expressionName) -> {x, p}
      expression-name-ok(s, expressionName, p)
    , datum(p, (x, ty))
  | LHS2FA(fieldAccess) ->
      field-access-ty(s, fieldAccess, ty)
  }.

unqualified-instance-ok(s, ui, ty) :- ui match
  { NewInstance(maybeTypeArguments, annotations, id, qualifiedIds, maybeTypeArgumentsOrDiamond, expressions) -> {classType, tys}
    // instantiated type
      unqualified-instance-type-ok(s, id, qualifiedIds, ty)
    // TODO type parameters
    // TODO constructor checking
    , expressions-ok(s, expressions, tys)
  }.

unqualified-instance-type-ok(s, id, qualifiedIds, ty) :- qualifiedIds match
  { [] -> {reached}
      query s `LEX*`EXT*`IMPL*`TYPE as reached
    , unambiguous-class(reached, id, ty)
  | QualifiedId(_, id'):qualifiedIds -> {ty', s_ty', reached}
      unqualified-instance-type-ok(s, id, qualifiedIds, ty')
    , type-scope(ty', s_ty')
    , query s_ty' `TYPE as reached
    , unambiguous-class(reached, id, ty)
  }.

qualified-instance-ok(s, ui, s_cls, ty) :- ui match
  { NewInstance(maybeTypeArguments, annotations, id, qualifiedIds, maybeTypeArgumentsOrDiamond, expressions) -> {classType, tys}
    // instantiated type
      qualified-instance-type-ok(s_cls, id, qualifiedIds, ty)
    // TODO type parameters
    // TODO constructor checking
    , expressions-ok(s, expressions, tys)
  }.

qualified-instance-type-ok(s_ty, id, qualifiedIds, ty) :- qualifiedIds match
  { [] -> {reached}
      query s_ty `EXT*`IMPL*`TYPE as reached
    , unambiguous-class(reached, id, ty)
  | QualifiedId(_, id'):qualifiedIds -> {ty', s_ty', reached}
      qualified-instance-type-ok(s_ty, id, qualifiedIds, ty')
    , type-scope(ty', s_ty')
    , query s_ty' `TYPE as reached
    , unambiguous-class(reached, id, ty)
  }.

// field-access-ty : scope * FieldAccess * Type

field-access-ty(s, fa, ty) :- {p} 
  fa match
    { Field(e, id) -> {s_type, reached, targs, tydecl, gens}
	expression-ok(s, e, OBJECT(tydecl, targs))
	, type-scope(tydecl, s_type)
	, query s_type `EXT*`VAR as reached
	, unambiguous-field(reached, id, p)
	, normalized-field-ty(p, targs, ty)
    | SuperField(id) -> {super, tydecl, targs, reached, gens}
    	super-type(s, OBJECT(tydecl, targs))
	, type-scope(tydecl, super)
    	, query super `EXT*`VAR as reached
    	, unambiguous-field(reached, id, p)
	, normalized-field-ty(p, targs, ty)
    // | QSuperField(typeName, id) -> {ty_this, reached, s_cls, p, x}
    // 	this-type(s, ty_this)
    // 	, type-name-ok(s, typeName, p)
    // 	, datum(p, (x, CLASS(s_cls)))
    // 	, sub-type(ty_this, CLASS(s_cls))
    // 	, query s_cls `EXT*`VAR as reached
    // 	, unambiguous-field(reached, id, p)
    }.
    
normalized-field-ty(p, targs, ty) :- p match
  { Edge(s_type, `EXT(targs'), p) -> {params, ty', tyname, tydecl}
      s_type -> (tyname, tydecl)
    , type-formal-params(tydecl, params)
    , normalized-field-ty(p, targs', ty')
    , substn(targs, params, ty', ty)
  | Edge(s_type, `IMPL(targs'), p) -> {params, tyname, tydecl, ty'}
      s_type -> (tyname, tydecl)
    , type-formal-params(tydecl, params)
    , normalized-field-ty(p, targs', ty')
    , substn(targs, params, ty', ty)
  | Edge(s_type, `VAR, p) -> {params, tyname, tydecl, varname, varty}
      s_type -> (tyname, tydecl)
    , type-formal-params(tydecl, params)
    , datum(p, (varname, varty))
    , substn(targs, params, varty, ty)
  | Edge(_, `LEX, p) -> normalized-field-ty(p, targs, ty)
  }.

substn(tys, vars, ty, out) :- ty match 
  { OBJECT(TVAR(var), []) ->  {tydecl, params'}
        substn-tvar(tys, vars, var, tydecl)
      , out = tydecl
  | OBJECT(tydecl, params) ->  {params'}
        substn-all(tys, vars, params, params')
      , out = OBJECT(tydecl, params')
  }.

substn-all(tys, vars, ins, outs) :- ins match 
  { i:ins' -> {out, outs'} 
        substn(tys, vars, i, out)
      , substn-all(tys, vars, ins', outs')
      , outs = out:outs'
  | [] -> outs = []
  }.

substn-tvar(tys, vars, x, out) :- tys match
  { ty:tys' -> {y, ys, out'} 
        vars = y:ys
      , subst-tvar(ty, y, x, out')
      , substn(tys', ys, out', out)
  | [] -> out = TVAR(x)
  }.

subst-tvar(ty, var, x, out) :- x match 
  { z where z = var -> out = ty
  | _               -> out = x
  }.

unambiguous-field(reached, id, p) :- {matched, visible}
  filter reached ((id', _) where id' = id) matched
, min matched
      lexico( `VAR < `LEX, `VAR < `EXT
            , `EXT < `LEX
            )
      visible
, only(visible, p).

// literal-type : scope * Literal * Type

literal-type(s, l, ty) :- l match
  { L2IL(il) -> int-literal-type(s, il, ty)
  | L2BL(bl) -> bool-literal-type(s, bl, ty)
  | L2SL(sl) -> string-literal-type(s, sl, ty)
  | L2NL(nl) -> null-literal-type(s, nl, ty)
  }.

// bool-literal-type : scope * BoolLiteral * Type

bool-literal-type(s, bl, ty) :- bl match
  { True()  -> ty = BOOL()
  | False() -> ty = BOOL()
  }.

// int-literal-type : scope * IntLiteral * Type

int-literal-type(s, il, ty) :- il match
  { Deci(_) -> ty = INT()
  | Hexa(_) -> ty = INT()
  | Octa(_) -> ty = INT()
  | Bin(_)  -> ty = INT()
  }.

// string-literal-type : scope * StringLiteral * Type

string-literal-type(s, sl, ty) :- sl match
  { String() -> ty = STRING()
  }.

// null-literal-type : scope * NullLiteral * Type

null-literal-type(s, nl, ty) :- nl match
  { Null() -> ty = NULL()
  }.

// package-name-ok : scope * PackageName * path

package-name-ok(s, tn, p) :- tn match
  { PackageName(id) ->
      false
  | PackageName(packageName, id) ->
      false
  }.

// type-name-ok : scope * TypeName * path

type-name-ok(s, tn, p) :- tn match
  { TypeName(id) -> {reached, matched, visible}
      query s `LEX*`EXT*`IMPL*`TYPE as reached
    , filter reached ((id', _) where id' = id) matched
    , min matched
          lexico( `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMPL
                , `EXT < `IMPL, `EXT < `LEX
                , `IMPL < `LEX
                )
          visible
    , only(visible, p)
  | TypeName(packageOrTypeName, id) ->
      false
  }.

// expression-name-ok : scope * ExpressionName * path

expression-name-ok(s, en, p) :- en match
  { ExpressionName(id) -> {reached, matched, visible}
      query s `LEX*`EXT*`VAR as reached
    , filter reached ((id', _) where id' = id) matched
    , min matched
          lexico( `VAR < `LEX, `VAR < `EXT
                , `EXT < `LEX
                )
          visible
    , only(visible, p)
  | ExpressionName(ambiguousName, id) ->
      false
  }.

// ambiguous-name-ok : scope * AmbiguousName * path

ambiguous-name-ok(s, an, p) :- an match
  { AmbiguousName(id) ->
      false
  | AmbiguousName(ambiguousName, id) ->
      false
  }.

// method-name-ok : scope * MethodName * path

method-name-ok(s, mn, p) :- mn match
  { MethodName(id) ->
      false
  }.

// primitive-type-ok : scope * PrimitiveType

primitive-type-ok(s, pt, ty) :- pt match
  { NumericType(annotations, nt) -> numeric-type-ok(s, nt, ty)
  | BooleanType(annotations)     -> ty = BOOLEAN()
  }.

// reference-type-ok : scope * ReferenceType

reference-type-ok(s, rt, ty) :- rt match
  { RT2CT(ct) -> class-type-ok(s, ct, ty)
  }.

// class-types-ok maps class-type-ok(*, list(*)) = list(*)

class-types-ok(s, cts, tys) :- cts match
  { ct:cts' -> {ty, tys'}
       class-type-ok(s, ct, ty)
     , class-types-ok(s, cts', tys')
     , tys = ty:tys'
  | []      -> tys = []
  }.

// class-type-ok : scope * ClassType -> TYPE

class-type-ok(s, ct, ty) :- ct match
  { ClassType(annotations, id, maybeTypeArguments) -> {reached, cls, tas}
      query s `LEX*(`EXT*`IMPL*|`GENERICS)`TYPE  as reached
      , unambiguous-class(reached, id, cls)
      , maybe-type-arguments-ok(s, maybeTypeArguments, tas)
      , ty = OBJECT(cls, tas)
  // | ClassOrInterfaceTypeMember(classType, annotations, id, maybeTypeArguments) -> {tydecl, targs, s_ty, reached, tas}
  //       class-type-ok(s, classType, OBJECT(tydecl, targs))
  //     , type-scope(tydecl, s_ty)
  //     , query s_ty `EXT*`TYPE as reached // TODO direct type members only? Or also inherited?
  //     , {inner_tydecl} 
  //         unambiguous-class(reached, id, inner_tydecl)
  //     	, maybe-type-arguments-ok(s, maybeTypeArguments, tas)
  }.

unambiguous-class(reached, id, ty) :- {matched, visible, p, x}
  filter reached ((id', _) where id' = id) matched
, min matched
      lexico( `TYPE < `LEX, `TYPE < `EXT, `TYPE < `IMPL, `TYPE < `GENERICS
            , `EXT < `LEX, `EXT < `IMPL, `EXT < `IMPL
	    , `GENERICS < `LEX, `GENERICS < `EXT, `GENERICS < `IMPL
            )
      visible
, only(visible, p)
, datum(p, (x, ty)).

// unann-type-ok : scope * UnannType

unann-type-ok(s, ut, ty) :- ut match
  { UT2UPT(upt) -> unann-primitive-type-ok(s, upt, ty)
  | UT2URT(urt) -> unann-reference-type-ok(s, urt, ty)
  }.

// unann-primitive-type-ok : scope * UnannPrimitiveType

unann-primitive-type-ok(s, upt, ty) :- upt match
  { NumericType(nt) -> numeric-type-ok(s, nt, ty)
  | BooleanType()   -> ty = BOOLEAN()
  }.

// unann-reference-type-ok : scope * UnannReferenceType

unann-reference-type-ok(s, urt, ty) :- urt match
  { URT2UCT(uct) -> unann-class-type-ok(s, uct, ty)
  }.

// unann-class-type-ok : scope * UnannClassType

unann-class-type-ok(s, urt, ty) :- urt match
  { ClassType(id, maybeTypeArguments) -> {reached, cls, tas}
      query s `LEX*(`EXT*`IMPL*|`GENERICS)`TYPE  as reached
    , unambiguous-class(reached, id, cls)
    , maybe-type-arguments-ok(s, maybeTypeArguments, tas)
    , ty = OBJECT(cls, tas)
  // | ClassOrInterfaceTypeMember(unannClassType, annotations, id, maybeTypeArguments) -> {ty', s_ty', reached}
  //     unann-class-type-ok(s, unannClassType, ty')
  //   , type-scope(ty', s_ty')
  //   , query s_ty' `TYPE as reached
  //   , unambiguous-class(reached, id, ty)
  }.

maybe-type-arguments-ok(s, maybeTypeArguments, tps) :- maybeTypeArguments match
  { None()                    -> tps = []
  | Some(TypeArguments(ftps)) -> type-arguments-ok(s, ftps, tps)
  }.

type-arguments-ok(s, typeArguments, tps) :- typeArguments match
  { ta:tas -> {tp, tps'}
      tps = tp:tps'
    , reference-type-ok(s, ta, tp)
    , type-arguments-ok(s, tas, tps')
  | [] -> tps = []
  }.


// numeric-type-ok : scope * NumericType

numeric-type-ok(s, nt, ty) :- nt match
  { Byte()   -> ty = BYTE()
  | Short()  -> ty = SHORT()
  | Int()    -> ty = INT()
  | Long()   -> ty = LONG()
  | Char()   -> ty = CHAR()
  | Float()  -> ty = FLOAT()
  | Double() -> ty = DOUBLE()
  }.

// sub-type : Type * Type

child-of(left, right) :- (left, right) match
  { (CLASS(left, _), CLASS(right, _)) -> {reaches, matches, ty}
      query left `EXT* as reaches
      , filter reaches ((_, CLASS(cls, _)) where cls = right) matches
      , only(matches, ty) // non-ambiguous super
  | (CLASS(left, _), INTF(right, _))  -> {reaches, matches, ty}
      query left `EXT*`IMPL* as reaches
      , filter reaches ((_, INTF(intf, _)) where intf = right) matches
      , inhabited(matches)
  }.

sub-types(txs, tys) :- (txs, tys) match
  { (tx:txs, ty:tys) -> sub-type(tx, ty), sub-types(txs, tys)
  | ([],[])          -> true
  }.

sub-type(ty1, ty2) :- (ty1, ty2) match
  {
    (BYTE(), BYTE())					-> true
  | (SHORT(), SHORT())					-> true
  | (INT(), INT())					-> true
  | (LONG(), LONG())					-> true
  | (CHAR(), CHAR())					-> true
  | (FLOAT(), FLOAT())					-> true
  | (DOUBLE(), DOUBLE())				-> true

  | (OBJECT(tydecl1, tps), OBJECT(tydecl2, tps'))	->
       child-of(tydecl1, tydecl2)
     , sub-types(tps, tps')
  | (NULL(), OBJECT(_,_))				-> true 
  }.

// ----------------

// s is the target scope of a path p
tgt(p,s) :- p match
  { End(x)       -> s = x
  | Edge(x,l,xs) -> tgt(xs,s)
  }.

// s is the source scope of a path p
src(p,s) :- p match
  { End(x)       -> s = x
  | Edge(x,l,xs) -> s = x
  }.

// d is the datum of the target of p
datum(p,d) :- {s} tgt(p, s), s -> d.

this-type(s, ty) :- {reached, visible, p}
  query s `LEX*`THIS as reached
  , min reached lexico(`THIS < `LEX) visible
  , only(visible, p)
  , datum(p, ty).

// TEST can one not use super for interface members?
super-type(s, ty) :- {self, tydecl, targs, cls, supers, p}
  this-type(s, OBJECT(tydecl, targs))
  , type-scope(tydecl, cls)
  , query cls `EXT as supers
  , only(supers, p) 
  , p match { Edge(_, `EXT(targs'), p') ->  {name, decl}
      datum(p', (name, decl))
    , ty = OBJECT(decl, targs') }.

return-type(s, ty) :- {reached, visible, p}
  query s `LEX*`RETURN as reached
, min reached lexico(`RETURN < `LEX) visible
, only(visible, p)
, datum(p, ty).

type-scope(ty, s_ty) :- ty match
  { CLASS(s_cls,_) -> s_ty = s_cls
  | INTF(s_intf,_) -> s_ty = s_intf
  }.

type-formal-params(ty, ftps) :- ty match
  { CLASS(_,gens)  -> ftps = gens
  | INTF(_,gens)   -> ftps = gens
  }.

is-class-or-interface-type(tp) :- tp match
  { CLASS(_,_)  -> true
  | INTF(_,_)   -> true
  | otherwise   -> false
  }.

are-interfaces(tps) :- tps match
  { INTF(_,_):tps -> are-interfaces(tps)
  | []            -> true
  | otherwise     -> false
  }.
